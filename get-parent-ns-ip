#!/usr/bin/env perl
use 5.016;
use warnings;

my $begin_time;

BEGIN {
    $begin_time = time();
}

use Getopt::Long qw( :config gnu_getopt );
use My::ExecutorCache;
use My::ExecutorFilter;
use My::FifoExecutor;
use My::MethodsV2 qw( get_parent_ns_ip );
use My::ParExecutor;
use My::Scheduler qw( block_on );
use Readonly;
use Time::HiRes   qw( time );
use Pod::Usage;

Readonly my %root_name_servers => {
    'a.root-servers.net.' => [ '198.41.0.4',     '2001:503:ba3e::2:30' ],
    'b.root-servers.net.' => [ '170.247.170.2',  '2801:1b8:10::b' ],
    'c.root-servers.net.' => [ '192.33.4.12',    '2001:500:2::c' ],
    'd.root-servers.net.' => [ '199.7.91.13',    '2001:500:2d::d' ],
    'e.root-servers.net.' => [ '192.203.230.10', '2001:500:a8::e' ],
    'f.root-servers.net.' => [ '192.5.5.241',    '2001:500:2f::f' ],
    'g.root-servers.net.' => [ '192.112.36.4',   '2001:500:12::d0d' ],
    'h.root-servers.net.' => [ '198.97.190.53',  '2001:500:1::53' ],
    'i.root-servers.net.' => [ '192.36.148.17',  '2001:7fe::53' ],
    'j.root-servers.net.' => [ '192.58.128.30',  '2001:503:c27::2:30' ],
    'k.root-servers.net.' => [ '193.0.14.129',   '2001:7fd::1' ],
    'l.root-servers.net.' => [ '199.7.83.42',    '2001:500:9f::42' ],
    'm.root-servers.net.' => [ '202.12.27.33',   '2001:dc3::35' ],
};

my $opt_help     = 0;
my $opt_ipv4     = 1;
my $opt_ipv6     = 1;
my $opt_strategy = 'par';

GetOptions(
    'help|h'       => \$opt_help,
    'ipv4!'        => \$opt_ipv4,
    'ipv6!'        => \$opt_ipv6,
    'strategy|s=s' => \$opt_strategy,
) or pod2usage( 2 );

pod2usage( 1 ) if $opt_help;

my $domain = $ARGV[0] // pod2usage( "DOMAIN not specified" );

if ( $opt_strategy !~ /^(par|seq)$/ ) {
    pod2usage( "invalid --strategy argument" );
}

my $executor;
if ( $opt_strategy eq 'par' ) {
    $executor = My::ParExecutor->new;
}
else {
    $executor = My::FifoExecutor->new;
}

$executor = My::ExecutorCache->new( $executor );

if ( !$opt_ipv4 || !$opt_ipv6 ) {
    $executor = My::ExecutorFilter->new( $executor, ipv4 => $opt_ipv4, ipv6 => $opt_ipv6 );
}

printf( "%8.2fs  starting\n", time() - $begin_time );

block_on(
    $executor,
    sub {
        my ( $scheduler ) = @_;

        $scheduler->handle(
            get_parent_ns_ip( $domain, \%root_name_servers ),
            sub {
                my ( $result ) = @_;
                printf( "%8.2fs  %s\n", time() - $begin_time, $result );
            }
        );
    }
);

printf( "%8.2fs  done\n", time() - $begin_time );

=head1 SYNOPSIS

get-parent-ns-ip [OPTIONS] DOMAIN

=head1 ARGUMENTS

=over 4

=item DOMAIN

The domain to examine.

=back

=head1 OPTIONS

=over 4

=item -h, --help

Show brief usage documentation.

=item --[no]ipv4

Enable/disable using IPv4.
Default: enabled.

=item --[no]ipv6

Enable/disable using IPv6.
Default: enabled.

=item -s STRATEGY, --strategy=STRATEGY

Select command execution strategy.
Default: parallel.

Valid values are C<par> for parallel and C<seq> for sequential.

=back

=head1 CAVEATS

The current implementation has many notable deficiencies. Here is a non-exhaustive list.

=over 4

=item Blacklisting

Blacklisting is not currently implemented. This is not significant when using the C<par>
command execution strategy since the timeouts are largely resoved in parallel.

=item Out-of-bailiwick nameserver address lookup

Instead of performing our own lookup of out-of-bailiwick nameserver addresses in a way
that respects root hints, the current implementation is cheating by simply asking Quad9 to
perform a recursive lookup for us.

=item Root hints

=item Fake delegation

=back

=cut
